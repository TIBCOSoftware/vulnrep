// Code generated by genenums - DO NOT EDIT
//
// This file implements marshaling and unmarshalling to JSON and XML for the
// purposes of having types with enumerated values - that serialize to different
// values in XML vs. JSON.
//
// Types and their values are defined in a JSON file, and provided to the
// genenums tool.

package vulnrep

import (
	"encoding/json"
	"encoding/xml"
	"fmt"
	"strings"
)

func xmlElemAsString(d *xml.Decoder, start xml.StartElement) (string, error) {
	var s string
	if err := d.DecodeElement(&s, &start); err != nil {
		return "", err
	}
	return s, nil
}

func noQuotes(b []byte) string {
	return strings.TrimSuffix(strings.TrimPrefix(string(b), "\""), "\"")
}

/*******************************************************************************
* Generated type RelationshipType
*******************************************************************************/

// RelationshipType defines possible relations between components.
type RelationshipType int

// Values for RelationshipType
const (
	RelationshipDefaultComponentOf RelationshipType = iota
	RelationshipOptionalComponentOf
	RelationshipExternalComponentOf
	RelationshipInstalledOn
	RelationshipInstalledWith

	maxRelationshipType
)

var genRelationshipTypeToXMLStr = map[RelationshipType]string{
	RelationshipDefaultComponentOf:  "Default Component Of",
	RelationshipOptionalComponentOf: "Optional Component Of",
	RelationshipExternalComponentOf: "External Component Of",
	RelationshipInstalledOn:         "Installed On",
	RelationshipInstalledWith:       "Installed With",
}

var genXMLStrToRelationshipType = map[string]RelationshipType{
	"Default Component Of":  RelationshipDefaultComponentOf,
	"Optional Component Of": RelationshipOptionalComponentOf,
	"External Component Of": RelationshipExternalComponentOf,
	"Installed On":          RelationshipInstalledOn,
	"Installed With":        RelationshipInstalledWith,
}

// UnmarshalXML implemented to support reading from XML.
func (obj *RelationshipType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	s, err := xmlElemAsString(d, start)
	if err != nil {
		return fmt.Errorf("problem decoding RelationshipType: %v", err)
	}
	var ok bool
	if *obj, ok = genXMLStrToRelationshipType[s]; !ok {
		return fmt.Errorf("unrecognized RelationshipType value %v", s)
	}
	return nil
}

func (obj *RelationshipType) mapXMLValue(s string) error {
	var ok bool
	if *obj, ok = genXMLStrToRelationshipType[s]; !ok {
		return fmt.Errorf("unrecognized RelationshipType value %v", s)
	}
	return nil
}

// UnmarshalXMLAttr implemented to support reading from XML
func (obj *RelationshipType) UnmarshalXMLAttr(attr xml.Attr) error {
	return obj.mapXMLValue(attr.Value)
}

// MarshalXMLAttr implemented to support writing to XML.
func (obj RelationshipType) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	s, ok := genRelationshipTypeToXMLStr[obj]
	if !ok {
		return xml.Attr{}, fmt.Errorf("unrecognized RelationshipType value %v", obj)
	}
	return xml.Attr{Name: name, Value: s}, nil
}

// MarshalXML implemented to support writing to XML.
func (obj RelationshipType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	s, ok := genRelationshipTypeToXMLStr[obj]
	if !ok {
		return fmt.Errorf("unrecognized RelationshipType %v", obj)
	}
	return e.EncodeElement(s, start)
}

var genJSONStrToRelationshipType = map[string]RelationshipType{
	"default_component_of":  RelationshipDefaultComponentOf,
	"optional_component_of": RelationshipOptionalComponentOf,
	"external_component_of": RelationshipExternalComponentOf,
	"installed_on":          RelationshipInstalledOn,
	"installed_with":        RelationshipInstalledWith,
}

var genRelationshipTypeToJSONStr = map[RelationshipType]string{
	RelationshipDefaultComponentOf:  "default_component_of",
	RelationshipOptionalComponentOf: "optional_component_of",
	RelationshipExternalComponentOf: "external_component_of",
	RelationshipInstalledOn:         "installed_on",
	RelationshipInstalledWith:       "installed_with",
}

// UnmarshalJSON implemented to support writing to XML.
func (obj *RelationshipType) UnmarshalJSON(data []byte) error {
	var ok bool
	if *obj, ok = genJSONStrToRelationshipType[noQuotes(data)]; !ok {
		return fmt.Errorf("unrecognized RelationshipType value %v", string(data))
	}
	return nil
}

// MarshalJSON implemented to support writing to XML.
func (obj RelationshipType) MarshalJSON() ([]byte, error) {
	s, ok := genRelationshipTypeToJSONStr[obj]
	if !ok {
		return nil, fmt.Errorf("unrecognized RelationshipType value %v", obj)
	}
	return json.Marshal(s)
}

func (obj RelationshipType) check(val *Validator) {
	if obj < 0 || obj >= maxRelationshipType {
		val.err(fmt.Sprintf("unrecognized RelationshipType %v", obj))
	}
}

/*******************************************************************************
* Generated type InvolvementStatusType
*******************************************************************************/

// InvolvementStatusType captures the ongoing involvement of other parties
type InvolvementStatusType int

// Values for InvolvementStatusType
const (
	InvolvementStatusOpen InvolvementStatusType = iota
	InvolvementStatusDisputed
	InvolvementStatusInProgress
	InvolvementStatusCompleted
	InvolvementStatusContactAttempted
	InvolvementStatusNotContacted

	maxInvolvementStatusType
)

var genInvolvementStatusTypeToXMLStr = map[InvolvementStatusType]string{
	InvolvementStatusOpen:             "Open",
	InvolvementStatusDisputed:         "Disputed",
	InvolvementStatusInProgress:       "In Progress",
	InvolvementStatusCompleted:        "Completed",
	InvolvementStatusContactAttempted: "Contact Attempted",
	InvolvementStatusNotContacted:     "Not Contacted",
}

var genXMLStrToInvolvementStatusType = map[string]InvolvementStatusType{
	"Open":              InvolvementStatusOpen,
	"Disputed":          InvolvementStatusDisputed,
	"In Progress":       InvolvementStatusInProgress,
	"Completed":         InvolvementStatusCompleted,
	"Contact Attempted": InvolvementStatusContactAttempted,
	"Not Contacted":     InvolvementStatusNotContacted,
}

// UnmarshalXML implemented to support reading from XML.
func (obj *InvolvementStatusType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	s, err := xmlElemAsString(d, start)
	if err != nil {
		return fmt.Errorf("problem decoding InvolvementStatusType: %v", err)
	}
	var ok bool
	if *obj, ok = genXMLStrToInvolvementStatusType[s]; !ok {
		return fmt.Errorf("unrecognized InvolvementStatusType value %v", s)
	}
	return nil
}

func (obj *InvolvementStatusType) mapXMLValue(s string) error {
	var ok bool
	if *obj, ok = genXMLStrToInvolvementStatusType[s]; !ok {
		return fmt.Errorf("unrecognized InvolvementStatusType value %v", s)
	}
	return nil
}

// UnmarshalXMLAttr implemented to support reading from XML
func (obj *InvolvementStatusType) UnmarshalXMLAttr(attr xml.Attr) error {
	return obj.mapXMLValue(attr.Value)
}

// MarshalXMLAttr implemented to support writing to XML.
func (obj InvolvementStatusType) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	s, ok := genInvolvementStatusTypeToXMLStr[obj]
	if !ok {
		return xml.Attr{}, fmt.Errorf("unrecognized InvolvementStatusType value %v", obj)
	}
	return xml.Attr{Name: name, Value: s}, nil
}

// MarshalXML implemented to support writing to XML.
func (obj InvolvementStatusType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	s, ok := genInvolvementStatusTypeToXMLStr[obj]
	if !ok {
		return fmt.Errorf("unrecognized InvolvementStatusType %v", obj)
	}
	return e.EncodeElement(s, start)
}

var genJSONStrToInvolvementStatusType = map[string]InvolvementStatusType{
	"open":              InvolvementStatusOpen,
	"disputed":          InvolvementStatusDisputed,
	"in_progress":       InvolvementStatusInProgress,
	"completed":         InvolvementStatusCompleted,
	"contact_attempted": InvolvementStatusContactAttempted,
	"not_contacted":     InvolvementStatusNotContacted,
}

var genInvolvementStatusTypeToJSONStr = map[InvolvementStatusType]string{
	InvolvementStatusOpen:             "open",
	InvolvementStatusDisputed:         "disputed",
	InvolvementStatusInProgress:       "in_progress",
	InvolvementStatusCompleted:        "completed",
	InvolvementStatusContactAttempted: "contact_attempted",
	InvolvementStatusNotContacted:     "not_contacted",
}

// UnmarshalJSON implemented to support writing to XML.
func (obj *InvolvementStatusType) UnmarshalJSON(data []byte) error {
	var ok bool
	if *obj, ok = genJSONStrToInvolvementStatusType[noQuotes(data)]; !ok {
		return fmt.Errorf("unrecognized InvolvementStatusType value %v", string(data))
	}
	return nil
}

// MarshalJSON implemented to support writing to XML.
func (obj InvolvementStatusType) MarshalJSON() ([]byte, error) {
	s, ok := genInvolvementStatusTypeToJSONStr[obj]
	if !ok {
		return nil, fmt.Errorf("unrecognized InvolvementStatusType value %v", obj)
	}
	return json.Marshal(s)
}

func (obj InvolvementStatusType) check(val *Validator) {
	if obj < 0 || obj >= maxInvolvementStatusType {
		val.err(fmt.Sprintf("unrecognized InvolvementStatusType %v", obj))
	}
}

/*******************************************************************************
* Generated type affectedStatusType
*******************************************************************************/

// affectedStatusType only used in XML - captures the status of affected components.
type affectedStatusType int

// Values for affectedStatusType
const (
	AffectedStatusFirstAffected affectedStatusType = iota
	AffectedStatusFirstFixed
	AffectedStatusFixed
	AffectedStatusKnownAffected
	AffectedStatusKnownNotAffected
	AffectedStatusLastAffected
	AffectedStatusRecommended

	maxaffectedStatusType
)

var genaffectedStatusTypeToXMLStr = map[affectedStatusType]string{
	AffectedStatusFirstAffected:    "First Affected",
	AffectedStatusFirstFixed:       "First Fixed",
	AffectedStatusFixed:            "Fixed",
	AffectedStatusKnownAffected:    "Known Affected",
	AffectedStatusKnownNotAffected: "Known Not Affected",
	AffectedStatusLastAffected:     "Last Affected",
	AffectedStatusRecommended:      "Recommended",
}

var genXMLStrToaffectedStatusType = map[string]affectedStatusType{
	"First Affected":     AffectedStatusFirstAffected,
	"First Fixed":        AffectedStatusFirstFixed,
	"Fixed":              AffectedStatusFixed,
	"Known Affected":     AffectedStatusKnownAffected,
	"Known Not Affected": AffectedStatusKnownNotAffected,
	"Last Affected":      AffectedStatusLastAffected,
	"Recommended":        AffectedStatusRecommended,
}

// UnmarshalXML implemented to support reading from XML.
func (obj *affectedStatusType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	s, err := xmlElemAsString(d, start)
	if err != nil {
		return fmt.Errorf("problem decoding affectedStatusType: %v", err)
	}
	var ok bool
	if *obj, ok = genXMLStrToaffectedStatusType[s]; !ok {
		return fmt.Errorf("unrecognized affectedStatusType value %v", s)
	}
	return nil
}

func (obj *affectedStatusType) mapXMLValue(s string) error {
	var ok bool
	if *obj, ok = genXMLStrToaffectedStatusType[s]; !ok {
		return fmt.Errorf("unrecognized affectedStatusType value %v", s)
	}
	return nil
}

// UnmarshalXMLAttr implemented to support reading from XML
func (obj *affectedStatusType) UnmarshalXMLAttr(attr xml.Attr) error {
	return obj.mapXMLValue(attr.Value)
}

// MarshalXMLAttr implemented to support writing to XML.
func (obj affectedStatusType) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	s, ok := genaffectedStatusTypeToXMLStr[obj]
	if !ok {
		return xml.Attr{}, fmt.Errorf("unrecognized affectedStatusType value %v", obj)
	}
	return xml.Attr{Name: name, Value: s}, nil
}

// MarshalXML implemented to support writing to XML.
func (obj affectedStatusType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	s, ok := genaffectedStatusTypeToXMLStr[obj]
	if !ok {
		return fmt.Errorf("unrecognized affectedStatusType %v", obj)
	}
	return e.EncodeElement(s, start)
}

var genJSONStrToaffectedStatusType = map[string]affectedStatusType{
	"first_affected":     AffectedStatusFirstAffected,
	"first_fixed":        AffectedStatusFirstFixed,
	"fixed":              AffectedStatusFixed,
	"known_affected":     AffectedStatusKnownAffected,
	"known_not_affected": AffectedStatusKnownNotAffected,
	"last_affected":      AffectedStatusLastAffected,
	"recommended":        AffectedStatusRecommended,
}

var genaffectedStatusTypeToJSONStr = map[affectedStatusType]string{
	AffectedStatusFirstAffected:    "first_affected",
	AffectedStatusFirstFixed:       "first_fixed",
	AffectedStatusFixed:            "fixed",
	AffectedStatusKnownAffected:    "known_affected",
	AffectedStatusKnownNotAffected: "known_not_affected",
	AffectedStatusLastAffected:     "last_affected",
	AffectedStatusRecommended:      "recommended",
}

// UnmarshalJSON implemented to support writing to XML.
func (obj *affectedStatusType) UnmarshalJSON(data []byte) error {
	var ok bool
	if *obj, ok = genJSONStrToaffectedStatusType[noQuotes(data)]; !ok {
		return fmt.Errorf("unrecognized affectedStatusType value %v", string(data))
	}
	return nil
}

// MarshalJSON implemented to support writing to XML.
func (obj affectedStatusType) MarshalJSON() ([]byte, error) {
	s, ok := genaffectedStatusTypeToJSONStr[obj]
	if !ok {
		return nil, fmt.Errorf("unrecognized affectedStatusType value %v", obj)
	}
	return json.Marshal(s)
}

func (obj affectedStatusType) check(val *Validator) {
	if obj < 0 || obj >= maxaffectedStatusType {
		val.err(fmt.Sprintf("unrecognized affectedStatusType %v", obj))
	}
}

/*******************************************************************************
* Generated type RemedyType
*******************************************************************************/

// RemedyType enumerates the types of remedies.
type RemedyType int

// Values for RemedyType
const (
	RemedyWorkaround RemedyType = iota
	RemedyMitigation
	RemedyVendorFix
	RemedyNoneAvailable
	RemedyWillNotFix

	maxRemedyType
)

var genRemedyTypeToXMLStr = map[RemedyType]string{
	RemedyWorkaround:    "Workaround",
	RemedyMitigation:    "Mitigation",
	RemedyVendorFix:     "Vendor Fix",
	RemedyNoneAvailable: "None Available",
	RemedyWillNotFix:    "Will Not Fix",
}

var genXMLStrToRemedyType = map[string]RemedyType{
	"Workaround":     RemedyWorkaround,
	"Mitigation":     RemedyMitigation,
	"Vendor Fix":     RemedyVendorFix,
	"None Available": RemedyNoneAvailable,
	"Will Not Fix":   RemedyWillNotFix,
}

// UnmarshalXML implemented to support reading from XML.
func (obj *RemedyType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	s, err := xmlElemAsString(d, start)
	if err != nil {
		return fmt.Errorf("problem decoding RemedyType: %v", err)
	}
	var ok bool
	if *obj, ok = genXMLStrToRemedyType[s]; !ok {
		return fmt.Errorf("unrecognized RemedyType value %v", s)
	}
	return nil
}

func (obj *RemedyType) mapXMLValue(s string) error {
	var ok bool
	if *obj, ok = genXMLStrToRemedyType[s]; !ok {
		return fmt.Errorf("unrecognized RemedyType value %v", s)
	}
	return nil
}

// UnmarshalXMLAttr implemented to support reading from XML
func (obj *RemedyType) UnmarshalXMLAttr(attr xml.Attr) error {
	return obj.mapXMLValue(attr.Value)
}

// MarshalXMLAttr implemented to support writing to XML.
func (obj RemedyType) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	s, ok := genRemedyTypeToXMLStr[obj]
	if !ok {
		return xml.Attr{}, fmt.Errorf("unrecognized RemedyType value %v", obj)
	}
	return xml.Attr{Name: name, Value: s}, nil
}

// MarshalXML implemented to support writing to XML.
func (obj RemedyType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	s, ok := genRemedyTypeToXMLStr[obj]
	if !ok {
		return fmt.Errorf("unrecognized RemedyType %v", obj)
	}
	return e.EncodeElement(s, start)
}

var genJSONStrToRemedyType = map[string]RemedyType{
	"workaround":     RemedyWorkaround,
	"mitigation":     RemedyMitigation,
	"vendor_fix":     RemedyVendorFix,
	"none_available": RemedyNoneAvailable,
	"will_not_fix":   RemedyWillNotFix,
}

var genRemedyTypeToJSONStr = map[RemedyType]string{
	RemedyWorkaround:    "workaround",
	RemedyMitigation:    "mitigation",
	RemedyVendorFix:     "vendor_fix",
	RemedyNoneAvailable: "none_available",
	RemedyWillNotFix:    "will_not_fix",
}

// UnmarshalJSON implemented to support writing to XML.
func (obj *RemedyType) UnmarshalJSON(data []byte) error {
	var ok bool
	if *obj, ok = genJSONStrToRemedyType[noQuotes(data)]; !ok {
		return fmt.Errorf("unrecognized RemedyType value %v", string(data))
	}
	return nil
}

// MarshalJSON implemented to support writing to XML.
func (obj RemedyType) MarshalJSON() ([]byte, error) {
	s, ok := genRemedyTypeToJSONStr[obj]
	if !ok {
		return nil, fmt.Errorf("unrecognized RemedyType value %v", obj)
	}
	return json.Marshal(s)
}

func (obj RemedyType) check(val *Validator) {
	if obj < 0 || obj >= maxRemedyType {
		val.err(fmt.Sprintf("unrecognized RemedyType %v", obj))
	}
}

/*******************************************************************************
* Generated type DocStatus
*******************************************************************************/

// DocStatus enumerates the possible states of a document.
type DocStatus int

// Values for DocStatus
const (
	DocStatusDraft DocStatus = iota
	DocStatusInterim
	DocStatusFinal

	maxDocStatus
)

var genDocStatusToXMLStr = map[DocStatus]string{
	DocStatusDraft:   "Draft",
	DocStatusInterim: "Interim",
	DocStatusFinal:   "Final",
}

var genXMLStrToDocStatus = map[string]DocStatus{
	"Draft":   DocStatusDraft,
	"Interim": DocStatusInterim,
	"Final":   DocStatusFinal,
}

// UnmarshalXML implemented to support reading from XML.
func (obj *DocStatus) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	s, err := xmlElemAsString(d, start)
	if err != nil {
		return fmt.Errorf("problem decoding DocStatus: %v", err)
	}
	var ok bool
	if *obj, ok = genXMLStrToDocStatus[s]; !ok {
		return fmt.Errorf("unrecognized DocStatus value %v", s)
	}
	return nil
}

func (obj *DocStatus) mapXMLValue(s string) error {
	var ok bool
	if *obj, ok = genXMLStrToDocStatus[s]; !ok {
		return fmt.Errorf("unrecognized DocStatus value %v", s)
	}
	return nil
}

// UnmarshalXMLAttr implemented to support reading from XML
func (obj *DocStatus) UnmarshalXMLAttr(attr xml.Attr) error {
	return obj.mapXMLValue(attr.Value)
}

// MarshalXMLAttr implemented to support writing to XML.
func (obj DocStatus) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	s, ok := genDocStatusToXMLStr[obj]
	if !ok {
		return xml.Attr{}, fmt.Errorf("unrecognized DocStatus value %v", obj)
	}
	return xml.Attr{Name: name, Value: s}, nil
}

// MarshalXML implemented to support writing to XML.
func (obj DocStatus) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	s, ok := genDocStatusToXMLStr[obj]
	if !ok {
		return fmt.Errorf("unrecognized DocStatus %v", obj)
	}
	return e.EncodeElement(s, start)
}

var genJSONStrToDocStatus = map[string]DocStatus{
	"draft":   DocStatusDraft,
	"interim": DocStatusInterim,
	"final":   DocStatusFinal,
}

var genDocStatusToJSONStr = map[DocStatus]string{
	DocStatusDraft:   "draft",
	DocStatusInterim: "interim",
	DocStatusFinal:   "final",
}

// UnmarshalJSON implemented to support writing to XML.
func (obj *DocStatus) UnmarshalJSON(data []byte) error {
	var ok bool
	if *obj, ok = genJSONStrToDocStatus[noQuotes(data)]; !ok {
		return fmt.Errorf("unrecognized DocStatus value %v", string(data))
	}
	return nil
}

// MarshalJSON implemented to support writing to XML.
func (obj DocStatus) MarshalJSON() ([]byte, error) {
	s, ok := genDocStatusToJSONStr[obj]
	if !ok {
		return nil, fmt.Errorf("unrecognized DocStatus value %v", obj)
	}
	return json.Marshal(s)
}

func (obj DocStatus) check(val *Validator) {
	if obj < 0 || obj >= maxDocStatus {
		val.err(fmt.Sprintf("unrecognized DocStatus %v", obj))
	}
}

/*******************************************************************************
* Generated type ReferenceType
*******************************************************************************/

// ReferenceType enumerates whether a references in self or external.
type ReferenceType int

// Values for ReferenceType
const (
	ReferenceExternal ReferenceType = iota
	ReferenceSelf

	maxReferenceType
)

var genReferenceTypeToXMLStr = map[ReferenceType]string{
	ReferenceExternal: "External",
	ReferenceSelf:     "Self",
}

var genXMLStrToReferenceType = map[string]ReferenceType{
	"External": ReferenceExternal,
	"Self":     ReferenceSelf,
}

// UnmarshalXML implemented to support reading from XML.
func (obj *ReferenceType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	s, err := xmlElemAsString(d, start)
	if err != nil {
		return fmt.Errorf("problem decoding ReferenceType: %v", err)
	}
	var ok bool
	if *obj, ok = genXMLStrToReferenceType[s]; !ok {
		return fmt.Errorf("unrecognized ReferenceType value %v", s)
	}
	return nil
}

func (obj *ReferenceType) mapXMLValue(s string) error {
	var ok bool
	if *obj, ok = genXMLStrToReferenceType[s]; !ok {
		return fmt.Errorf("unrecognized ReferenceType value %v", s)
	}
	return nil
}

// UnmarshalXMLAttr implemented to support reading from XML
func (obj *ReferenceType) UnmarshalXMLAttr(attr xml.Attr) error {
	return obj.mapXMLValue(attr.Value)
}

// MarshalXMLAttr implemented to support writing to XML.
func (obj ReferenceType) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	s, ok := genReferenceTypeToXMLStr[obj]
	if !ok {
		return xml.Attr{}, fmt.Errorf("unrecognized ReferenceType value %v", obj)
	}
	return xml.Attr{Name: name, Value: s}, nil
}

// MarshalXML implemented to support writing to XML.
func (obj ReferenceType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	s, ok := genReferenceTypeToXMLStr[obj]
	if !ok {
		return fmt.Errorf("unrecognized ReferenceType %v", obj)
	}
	return e.EncodeElement(s, start)
}

var genJSONStrToReferenceType = map[string]ReferenceType{
	"external": ReferenceExternal,
	"self":     ReferenceSelf,
}

var genReferenceTypeToJSONStr = map[ReferenceType]string{
	ReferenceExternal: "external",
	ReferenceSelf:     "self",
}

// UnmarshalJSON implemented to support writing to XML.
func (obj *ReferenceType) UnmarshalJSON(data []byte) error {
	var ok bool
	if *obj, ok = genJSONStrToReferenceType[noQuotes(data)]; !ok {
		return fmt.Errorf("unrecognized ReferenceType value %v", string(data))
	}
	return nil
}

// MarshalJSON implemented to support writing to XML.
func (obj ReferenceType) MarshalJSON() ([]byte, error) {
	s, ok := genReferenceTypeToJSONStr[obj]
	if !ok {
		return nil, fmt.Errorf("unrecognized ReferenceType value %v", obj)
	}
	return json.Marshal(s)
}

func (obj ReferenceType) check(val *Validator) {
	if obj < 0 || obj >= maxReferenceType {
		val.err(fmt.Sprintf("unrecognized ReferenceType %v", obj))
	}
}

/*******************************************************************************
* Generated type NoteType
*******************************************************************************/

// NoteType enuemrates the different types of Notes.
type NoteType int

// Values for NoteType
const (
	NoteDescription NoteType = iota
	NoteDetails
	NoteFAQ
	NoteGeneral
	NoteLegalDisclaimer
	NoteOther
	NoteSummary

	maxNoteType
)

var genNoteTypeToXMLStr = map[NoteType]string{
	NoteDescription:     "Description",
	NoteDetails:         "Details",
	NoteFAQ:             "FAQ",
	NoteGeneral:         "General",
	NoteLegalDisclaimer: "Legal Disclaimer",
	NoteOther:           "Other",
	NoteSummary:         "Summary",
}

var genXMLStrToNoteType = map[string]NoteType{
	"Description":      NoteDescription,
	"Details":          NoteDetails,
	"FAQ":              NoteFAQ,
	"General":          NoteGeneral,
	"Legal Disclaimer": NoteLegalDisclaimer,
	"Other":            NoteOther,
	"Summary":          NoteSummary,
}

// UnmarshalXML implemented to support reading from XML.
func (obj *NoteType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	s, err := xmlElemAsString(d, start)
	if err != nil {
		return fmt.Errorf("problem decoding NoteType: %v", err)
	}
	var ok bool
	if *obj, ok = genXMLStrToNoteType[s]; !ok {
		return fmt.Errorf("unrecognized NoteType value %v", s)
	}
	return nil
}

func (obj *NoteType) mapXMLValue(s string) error {
	var ok bool
	if *obj, ok = genXMLStrToNoteType[s]; !ok {
		return fmt.Errorf("unrecognized NoteType value %v", s)
	}
	return nil
}

// UnmarshalXMLAttr implemented to support reading from XML
func (obj *NoteType) UnmarshalXMLAttr(attr xml.Attr) error {
	return obj.mapXMLValue(attr.Value)
}

// MarshalXMLAttr implemented to support writing to XML.
func (obj NoteType) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	s, ok := genNoteTypeToXMLStr[obj]
	if !ok {
		return xml.Attr{}, fmt.Errorf("unrecognized NoteType value %v", obj)
	}
	return xml.Attr{Name: name, Value: s}, nil
}

// MarshalXML implemented to support writing to XML.
func (obj NoteType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	s, ok := genNoteTypeToXMLStr[obj]
	if !ok {
		return fmt.Errorf("unrecognized NoteType %v", obj)
	}
	return e.EncodeElement(s, start)
}

var genJSONStrToNoteType = map[string]NoteType{
	"description":      NoteDescription,
	"details":          NoteDetails,
	"faq":              NoteFAQ,
	"general":          NoteGeneral,
	"legal_disclaimer": NoteLegalDisclaimer,
	"other":            NoteOther,
	"summary":          NoteSummary,
}

var genNoteTypeToJSONStr = map[NoteType]string{
	NoteDescription:     "description",
	NoteDetails:         "details",
	NoteFAQ:             "faq",
	NoteGeneral:         "general",
	NoteLegalDisclaimer: "legal_disclaimer",
	NoteOther:           "other",
	NoteSummary:         "summary",
}

// UnmarshalJSON implemented to support writing to XML.
func (obj *NoteType) UnmarshalJSON(data []byte) error {
	var ok bool
	if *obj, ok = genJSONStrToNoteType[noQuotes(data)]; !ok {
		return fmt.Errorf("unrecognized NoteType value %v", string(data))
	}
	return nil
}

// MarshalJSON implemented to support writing to XML.
func (obj NoteType) MarshalJSON() ([]byte, error) {
	s, ok := genNoteTypeToJSONStr[obj]
	if !ok {
		return nil, fmt.Errorf("unrecognized NoteType value %v", obj)
	}
	return json.Marshal(s)
}

func (obj NoteType) check(val *Validator) {
	if obj < 0 || obj >= maxNoteType {
		val.err(fmt.Sprintf("unrecognized NoteType %v", obj))
	}
}

/*******************************************************************************
* Generated type PublisherType
*******************************************************************************/

// PublisherType enumerates the different publishers of vulnerabilities.
type PublisherType int

// Values for PublisherType
const (
	PubTypeVendor PublisherType = iota
	PubTypeDiscoverer
	PubTypeCoordinator
	PubTypeUser
	PubTypeOther

	maxPublisherType
)

var genPublisherTypeToXMLStr = map[PublisherType]string{
	PubTypeVendor:      "Vendor",
	PubTypeDiscoverer:  "Discoverer",
	PubTypeCoordinator: "Coordinator",
	PubTypeUser:        "User",
	PubTypeOther:       "Other",
}

var genXMLStrToPublisherType = map[string]PublisherType{
	"Vendor":      PubTypeVendor,
	"Discoverer":  PubTypeDiscoverer,
	"Coordinator": PubTypeCoordinator,
	"User":        PubTypeUser,
	"Other":       PubTypeOther,
}

// UnmarshalXML implemented to support reading from XML.
func (obj *PublisherType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	s, err := xmlElemAsString(d, start)
	if err != nil {
		return fmt.Errorf("problem decoding PublisherType: %v", err)
	}
	var ok bool
	if *obj, ok = genXMLStrToPublisherType[s]; !ok {
		return fmt.Errorf("unrecognized PublisherType value %v", s)
	}
	return nil
}

func (obj *PublisherType) mapXMLValue(s string) error {
	var ok bool
	if *obj, ok = genXMLStrToPublisherType[s]; !ok {
		return fmt.Errorf("unrecognized PublisherType value %v", s)
	}
	return nil
}

// UnmarshalXMLAttr implemented to support reading from XML
func (obj *PublisherType) UnmarshalXMLAttr(attr xml.Attr) error {
	return obj.mapXMLValue(attr.Value)
}

// MarshalXMLAttr implemented to support writing to XML.
func (obj PublisherType) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	s, ok := genPublisherTypeToXMLStr[obj]
	if !ok {
		return xml.Attr{}, fmt.Errorf("unrecognized PublisherType value %v", obj)
	}
	return xml.Attr{Name: name, Value: s}, nil
}

// MarshalXML implemented to support writing to XML.
func (obj PublisherType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	s, ok := genPublisherTypeToXMLStr[obj]
	if !ok {
		return fmt.Errorf("unrecognized PublisherType %v", obj)
	}
	return e.EncodeElement(s, start)
}

var genJSONStrToPublisherType = map[string]PublisherType{
	"vendor":      PubTypeVendor,
	"discoverer":  PubTypeDiscoverer,
	"coordinator": PubTypeCoordinator,
	"user":        PubTypeUser,
	"other":       PubTypeOther,
}

var genPublisherTypeToJSONStr = map[PublisherType]string{
	PubTypeVendor:      "vendor",
	PubTypeDiscoverer:  "discoverer",
	PubTypeCoordinator: "coordinator",
	PubTypeUser:        "user",
	PubTypeOther:       "other",
}

// UnmarshalJSON implemented to support writing to XML.
func (obj *PublisherType) UnmarshalJSON(data []byte) error {
	var ok bool
	if *obj, ok = genJSONStrToPublisherType[noQuotes(data)]; !ok {
		return fmt.Errorf("unrecognized PublisherType value %v", string(data))
	}
	return nil
}

// MarshalJSON implemented to support writing to XML.
func (obj PublisherType) MarshalJSON() ([]byte, error) {
	s, ok := genPublisherTypeToJSONStr[obj]
	if !ok {
		return nil, fmt.Errorf("unrecognized PublisherType value %v", obj)
	}
	return json.Marshal(s)
}

func (obj PublisherType) check(val *Validator) {
	if obj < 0 || obj >= maxPublisherType {
		val.err(fmt.Sprintf("unrecognized PublisherType %v", obj))
	}
}

/*******************************************************************************
* Generated type BranchType
*******************************************************************************/

// BranchType captures the type of branch in the product tree.
type BranchType int

// Values for BranchType
const (
	BranchVendor BranchType = iota
	BranchProductFamily
	BranchProductName
	BranchProductVersion
	BranchPatchLevel
	BranchServicePack
	BranchArchitecture
	BranchLanguage
	BranchLegacy
	BranchSpecification
	BranchHostName
	BranchRealm
	BranchResource

	maxBranchType
)

var genBranchTypeToXMLStr = map[BranchType]string{
	BranchVendor:         "Vendor",
	BranchProductFamily:  "Product Family",
	BranchProductName:    "Product Name",
	BranchProductVersion: "Product Version",
	BranchPatchLevel:     "Patch Level",
	BranchServicePack:    "Service Pack",
	BranchArchitecture:   "Architecture",
	BranchLanguage:       "Language",
	BranchLegacy:         "Legacy",
	BranchSpecification:  "Specification",
	BranchHostName:       "Host Name",
	BranchRealm:          "Realm",
	BranchResource:       "Resource",
}

var genXMLStrToBranchType = map[string]BranchType{
	"Vendor":          BranchVendor,
	"Product Family":  BranchProductFamily,
	"Product Name":    BranchProductName,
	"Product Version": BranchProductVersion,
	"Patch Level":     BranchPatchLevel,
	"Service Pack":    BranchServicePack,
	"Architecture":    BranchArchitecture,
	"Language":        BranchLanguage,
	"Legacy":          BranchLegacy,
	"Specification":   BranchSpecification,
	"Host Name":       BranchHostName,
	"Realm":           BranchRealm,
	"Resource":        BranchResource,
}

// UnmarshalXML implemented to support reading from XML.
func (obj *BranchType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	s, err := xmlElemAsString(d, start)
	if err != nil {
		return fmt.Errorf("problem decoding BranchType: %v", err)
	}
	var ok bool
	if *obj, ok = genXMLStrToBranchType[s]; !ok {
		return fmt.Errorf("unrecognized BranchType value %v", s)
	}
	return nil
}

func (obj *BranchType) mapXMLValue(s string) error {
	var ok bool
	if *obj, ok = genXMLStrToBranchType[s]; !ok {
		return fmt.Errorf("unrecognized BranchType value %v", s)
	}
	return nil
}

// UnmarshalXMLAttr implemented to support reading from XML
func (obj *BranchType) UnmarshalXMLAttr(attr xml.Attr) error {
	return obj.mapXMLValue(attr.Value)
}

// MarshalXMLAttr implemented to support writing to XML.
func (obj BranchType) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	s, ok := genBranchTypeToXMLStr[obj]
	if !ok {
		return xml.Attr{}, fmt.Errorf("unrecognized BranchType value %v", obj)
	}
	return xml.Attr{Name: name, Value: s}, nil
}

// MarshalXML implemented to support writing to XML.
func (obj BranchType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	s, ok := genBranchTypeToXMLStr[obj]
	if !ok {
		return fmt.Errorf("unrecognized BranchType %v", obj)
	}
	return e.EncodeElement(s, start)
}

var genJSONStrToBranchType = map[string]BranchType{
	"vendor":          BranchVendor,
	"product_family":  BranchProductFamily,
	"product_name":    BranchProductName,
	"product_version": BranchProductVersion,
	"patch_level":     BranchPatchLevel,
	"service_pack":    BranchServicePack,
	"architecture":    BranchArchitecture,
	"language":        BranchLanguage,
	"legacy":          BranchLegacy,
	"specification":   BranchSpecification,
	"host_name":       BranchHostName,
	"realm":           BranchRealm,
	"resource":        BranchResource,
}

var genBranchTypeToJSONStr = map[BranchType]string{
	BranchVendor:         "vendor",
	BranchProductFamily:  "product_family",
	BranchProductName:    "product_name",
	BranchProductVersion: "product_version",
	BranchPatchLevel:     "patch_level",
	BranchServicePack:    "service_pack",
	BranchArchitecture:   "architecture",
	BranchLanguage:       "language",
	BranchLegacy:         "legacy",
	BranchSpecification:  "specification",
	BranchHostName:       "host_name",
	BranchRealm:          "realm",
	BranchResource:       "resource",
}

// UnmarshalJSON implemented to support writing to XML.
func (obj *BranchType) UnmarshalJSON(data []byte) error {
	var ok bool
	if *obj, ok = genJSONStrToBranchType[noQuotes(data)]; !ok {
		return fmt.Errorf("unrecognized BranchType value %v", string(data))
	}
	return nil
}

// MarshalJSON implemented to support writing to XML.
func (obj BranchType) MarshalJSON() ([]byte, error) {
	s, ok := genBranchTypeToJSONStr[obj]
	if !ok {
		return nil, fmt.Errorf("unrecognized BranchType value %v", obj)
	}
	return json.Marshal(s)
}

func (obj BranchType) check(val *Validator) {
	if obj < 0 || obj >= maxBranchType {
		val.err(fmt.Sprintf("unrecognized BranchType %v", obj))
	}
}

/*******************************************************************************
* Generated type ThreatType
*******************************************************************************/

// ThreatType captures the type of threat.
type ThreatType int

// Values for ThreatType
const (
	ThreatImpact ThreatType = iota
	ThreatExploitStatus
	ThreatTargetSet

	maxThreatType
)

var genThreatTypeToXMLStr = map[ThreatType]string{
	ThreatImpact:        "Impact",
	ThreatExploitStatus: "Exploit Status",
	ThreatTargetSet:     "Target Set",
}

var genXMLStrToThreatType = map[string]ThreatType{
	"Impact":         ThreatImpact,
	"Exploit Status": ThreatExploitStatus,
	"Target Set":     ThreatTargetSet,
}

// UnmarshalXML implemented to support reading from XML.
func (obj *ThreatType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	s, err := xmlElemAsString(d, start)
	if err != nil {
		return fmt.Errorf("problem decoding ThreatType: %v", err)
	}
	var ok bool
	if *obj, ok = genXMLStrToThreatType[s]; !ok {
		return fmt.Errorf("unrecognized ThreatType value %v", s)
	}
	return nil
}

func (obj *ThreatType) mapXMLValue(s string) error {
	var ok bool
	if *obj, ok = genXMLStrToThreatType[s]; !ok {
		return fmt.Errorf("unrecognized ThreatType value %v", s)
	}
	return nil
}

// UnmarshalXMLAttr implemented to support reading from XML
func (obj *ThreatType) UnmarshalXMLAttr(attr xml.Attr) error {
	return obj.mapXMLValue(attr.Value)
}

// MarshalXMLAttr implemented to support writing to XML.
func (obj ThreatType) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	s, ok := genThreatTypeToXMLStr[obj]
	if !ok {
		return xml.Attr{}, fmt.Errorf("unrecognized ThreatType value %v", obj)
	}
	return xml.Attr{Name: name, Value: s}, nil
}

// MarshalXML implemented to support writing to XML.
func (obj ThreatType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	s, ok := genThreatTypeToXMLStr[obj]
	if !ok {
		return fmt.Errorf("unrecognized ThreatType %v", obj)
	}
	return e.EncodeElement(s, start)
}

var genJSONStrToThreatType = map[string]ThreatType{
	"impact":         ThreatImpact,
	"exploit_status": ThreatExploitStatus,
	"target_set":     ThreatTargetSet,
}

var genThreatTypeToJSONStr = map[ThreatType]string{
	ThreatImpact:        "impact",
	ThreatExploitStatus: "exploit_status",
	ThreatTargetSet:     "target_set",
}

// UnmarshalJSON implemented to support writing to XML.
func (obj *ThreatType) UnmarshalJSON(data []byte) error {
	var ok bool
	if *obj, ok = genJSONStrToThreatType[noQuotes(data)]; !ok {
		return fmt.Errorf("unrecognized ThreatType value %v", string(data))
	}
	return nil
}

// MarshalJSON implemented to support writing to XML.
func (obj ThreatType) MarshalJSON() ([]byte, error) {
	s, ok := genThreatTypeToJSONStr[obj]
	if !ok {
		return nil, fmt.Errorf("unrecognized ThreatType value %v", obj)
	}
	return json.Marshal(s)
}

func (obj ThreatType) check(val *Validator) {
	if obj < 0 || obj >= maxThreatType {
		val.err(fmt.Sprintf("unrecognized ThreatType %v", obj))
	}
}
