// Code generated by genenums - DO NOT EDIT
//
// This file implements marshaling and unmarshalling to JSON and XML for the
// purposes of having types with enumerated values - that serialize to different
// values in XML vs. JSON.
//
// Types and their values are defined in a JSON file, and provided to the
// genenums tool.

package vulnrep

import (
	"encoding/json"
	"encoding/xml"
	"fmt"
	"strings"
)

func xmlElemAsString(d *xml.Decoder, start xml.StartElement) (string, error) {
	var s string
	if err := d.DecodeElement(&s, &start); err != nil {
		return "", err
	}
	return s, nil
}

func noQuotes(b []byte) string {
	return strings.TrimSuffix(strings.TrimPrefix(string(b), "\""), "\"")
}

/*******************************************************************************
* Generated type RelationshipType
*******************************************************************************/

// RelationshipType defines possible relations between components.
type RelationshipType int
type expRelationshipType RelationshipType

// Values for RelationshipType
const (
	RelationshipDefaultComponentOf RelationshipType = iota
	RelationshipOptionalComponentOf
	RelationshipExternalComponentOf
	RelationshipInstalledOn
	RelationshipInstalledWith

	maxRelationshipType
)

var genRelationshipTypeToXMLStr = map[expRelationshipType]string{
	expRelationshipType(RelationshipDefaultComponentOf):  "Default Component Of",
	expRelationshipType(RelationshipOptionalComponentOf): "Optional Component Of",
	expRelationshipType(RelationshipExternalComponentOf): "External Component Of",
	expRelationshipType(RelationshipInstalledOn):         "Installed On",
	expRelationshipType(RelationshipInstalledWith):       "Installed With",
}

var genXMLStrToRelationshipType = map[string]expRelationshipType{
	"Default Component Of":  expRelationshipType(RelationshipDefaultComponentOf),
	"Optional Component Of": expRelationshipType(RelationshipOptionalComponentOf),
	"External Component Of": expRelationshipType(RelationshipExternalComponentOf),
	"Installed On":          expRelationshipType(RelationshipInstalledOn),
	"Installed With":        expRelationshipType(RelationshipInstalledWith),
}

// UnmarshalXML implemented to support reading from XML.
func (obj *expRelationshipType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	s, err := xmlElemAsString(d, start)
	if err != nil {
		return fmt.Errorf("problem decoding RelationshipType: %v", err)
	}
	var ok bool
	if *obj, ok = genXMLStrToRelationshipType[s]; !ok {
		return fmt.Errorf("unrecognized RelationshipType value %v", s)
	}
	return nil
}

func (obj *expRelationshipType) mapXMLValue(s string) error {
	var ok bool
	if *obj, ok = genXMLStrToRelationshipType[s]; !ok {
		return fmt.Errorf("unrecognized RelationshipType value %v", s)
	}
	return nil
}

// UnmarshalXMLAttr implemented to support reading from XML
func (obj *expRelationshipType) UnmarshalXMLAttr(attr xml.Attr) error {
	return obj.mapXMLValue(attr.Value)
}

// MarshalXMLAttr implemented to support writing to XML.
func (obj expRelationshipType) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	s, ok := genRelationshipTypeToXMLStr[obj]
	if !ok {
		return xml.Attr{}, fmt.Errorf("unrecognized RelationshipType value %v", obj)
	}
	return xml.Attr{Name: name, Value: s}, nil
}

// MarshalXML implemented to support writing to XML.
func (obj expRelationshipType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	s, ok := genRelationshipTypeToXMLStr[obj]
	if !ok {
		return fmt.Errorf("unrecognized RelationshipType %v", obj)
	}
	return e.EncodeElement(s, start)
}

var genJSONStrToRelationshipType = map[string]expRelationshipType{
	"default_component_of":  expRelationshipType(RelationshipDefaultComponentOf),
	"optional_component_of": expRelationshipType(RelationshipOptionalComponentOf),
	"external_component_of": expRelationshipType(RelationshipExternalComponentOf),
	"installed_on":          expRelationshipType(RelationshipInstalledOn),
	"installed_with":        expRelationshipType(RelationshipInstalledWith),
}

var genRelationshipTypeToJSONStr = map[expRelationshipType]string{
	expRelationshipType(RelationshipDefaultComponentOf):  "default_component_of",
	expRelationshipType(RelationshipOptionalComponentOf): "optional_component_of",
	expRelationshipType(RelationshipExternalComponentOf): "external_component_of",
	expRelationshipType(RelationshipInstalledOn):         "installed_on",
	expRelationshipType(RelationshipInstalledWith):       "installed_with",
}

// UnmarshalJSON implemented to support writing to XML.
func (obj *expRelationshipType) UnmarshalJSON(data []byte) error {
	var ok bool
	if *obj, ok = genJSONStrToRelationshipType[noQuotes(data)]; !ok {
		return fmt.Errorf("unrecognized RelationshipType value %v", string(data))
	}
	return nil
}

// MarshalJSON implemented to support writing to XML.
func (obj expRelationshipType) MarshalJSON() ([]byte, error) {
	s, ok := genRelationshipTypeToJSONStr[obj]
	if !ok {
		return nil, fmt.Errorf("unrecognized RelationshipType value %v", obj)
	}
	return json.Marshal(s)
}

func (obj RelationshipType) check(val *validator) {
	if obj < 0 || obj >= maxRelationshipType {
		val.err(fmt.Sprintf("unrecognized RelationshipType %v", obj))
	}
}

/*******************************************************************************
* Generated type InvolvementStatusType
*******************************************************************************/

// InvolvementStatusType captures the ongoing involvement of other parties
type InvolvementStatusType int
type expInvolvementStatusType InvolvementStatusType

// Values for InvolvementStatusType
const (
	InvolvementStatusOpen InvolvementStatusType = iota
	InvolvementStatusDisputed
	InvolvementStatusInProgress
	InvolvementStatusCompleted
	InvolvementStatusContactAttempted
	InvolvementStatusNotContacted

	maxInvolvementStatusType
)

var genInvolvementStatusTypeToXMLStr = map[expInvolvementStatusType]string{
	expInvolvementStatusType(InvolvementStatusOpen):             "Open",
	expInvolvementStatusType(InvolvementStatusDisputed):         "Disputed",
	expInvolvementStatusType(InvolvementStatusInProgress):       "In Progress",
	expInvolvementStatusType(InvolvementStatusCompleted):        "Completed",
	expInvolvementStatusType(InvolvementStatusContactAttempted): "Contact Attempted",
	expInvolvementStatusType(InvolvementStatusNotContacted):     "Not Contacted",
}

var genXMLStrToInvolvementStatusType = map[string]expInvolvementStatusType{
	"Open":              expInvolvementStatusType(InvolvementStatusOpen),
	"Disputed":          expInvolvementStatusType(InvolvementStatusDisputed),
	"In Progress":       expInvolvementStatusType(InvolvementStatusInProgress),
	"Completed":         expInvolvementStatusType(InvolvementStatusCompleted),
	"Contact Attempted": expInvolvementStatusType(InvolvementStatusContactAttempted),
	"Not Contacted":     expInvolvementStatusType(InvolvementStatusNotContacted),
}

// UnmarshalXML implemented to support reading from XML.
func (obj *expInvolvementStatusType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	s, err := xmlElemAsString(d, start)
	if err != nil {
		return fmt.Errorf("problem decoding InvolvementStatusType: %v", err)
	}
	var ok bool
	if *obj, ok = genXMLStrToInvolvementStatusType[s]; !ok {
		return fmt.Errorf("unrecognized InvolvementStatusType value %v", s)
	}
	return nil
}

func (obj *expInvolvementStatusType) mapXMLValue(s string) error {
	var ok bool
	if *obj, ok = genXMLStrToInvolvementStatusType[s]; !ok {
		return fmt.Errorf("unrecognized InvolvementStatusType value %v", s)
	}
	return nil
}

// UnmarshalXMLAttr implemented to support reading from XML
func (obj *expInvolvementStatusType) UnmarshalXMLAttr(attr xml.Attr) error {
	return obj.mapXMLValue(attr.Value)
}

// MarshalXMLAttr implemented to support writing to XML.
func (obj expInvolvementStatusType) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	s, ok := genInvolvementStatusTypeToXMLStr[obj]
	if !ok {
		return xml.Attr{}, fmt.Errorf("unrecognized InvolvementStatusType value %v", obj)
	}
	return xml.Attr{Name: name, Value: s}, nil
}

// MarshalXML implemented to support writing to XML.
func (obj expInvolvementStatusType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	s, ok := genInvolvementStatusTypeToXMLStr[obj]
	if !ok {
		return fmt.Errorf("unrecognized InvolvementStatusType %v", obj)
	}
	return e.EncodeElement(s, start)
}

var genJSONStrToInvolvementStatusType = map[string]expInvolvementStatusType{
	"open":              expInvolvementStatusType(InvolvementStatusOpen),
	"disputed":          expInvolvementStatusType(InvolvementStatusDisputed),
	"in_progress":       expInvolvementStatusType(InvolvementStatusInProgress),
	"completed":         expInvolvementStatusType(InvolvementStatusCompleted),
	"contact_attempted": expInvolvementStatusType(InvolvementStatusContactAttempted),
	"not_contacted":     expInvolvementStatusType(InvolvementStatusNotContacted),
}

var genInvolvementStatusTypeToJSONStr = map[expInvolvementStatusType]string{
	expInvolvementStatusType(InvolvementStatusOpen):             "open",
	expInvolvementStatusType(InvolvementStatusDisputed):         "disputed",
	expInvolvementStatusType(InvolvementStatusInProgress):       "in_progress",
	expInvolvementStatusType(InvolvementStatusCompleted):        "completed",
	expInvolvementStatusType(InvolvementStatusContactAttempted): "contact_attempted",
	expInvolvementStatusType(InvolvementStatusNotContacted):     "not_contacted",
}

// UnmarshalJSON implemented to support writing to XML.
func (obj *expInvolvementStatusType) UnmarshalJSON(data []byte) error {
	var ok bool
	if *obj, ok = genJSONStrToInvolvementStatusType[noQuotes(data)]; !ok {
		return fmt.Errorf("unrecognized InvolvementStatusType value %v", string(data))
	}
	return nil
}

// MarshalJSON implemented to support writing to XML.
func (obj expInvolvementStatusType) MarshalJSON() ([]byte, error) {
	s, ok := genInvolvementStatusTypeToJSONStr[obj]
	if !ok {
		return nil, fmt.Errorf("unrecognized InvolvementStatusType value %v", obj)
	}
	return json.Marshal(s)
}

func (obj InvolvementStatusType) check(val *validator) {
	if obj < 0 || obj >= maxInvolvementStatusType {
		val.err(fmt.Sprintf("unrecognized InvolvementStatusType %v", obj))
	}
}

/*******************************************************************************
* Generated type affectedStatusType
*******************************************************************************/

// affectedStatusType only used in XML - captures the status of affected components.
type affectedStatusType int
type expaffectedStatusType affectedStatusType

// Values for affectedStatusType
const (
	affectedStatusFirstAffected affectedStatusType = iota
	affectedStatusFirstFixed
	affectedStatusFixed
	affectedStatusKnownAffected
	affectedStatusKnownNotAffected
	affectedStatusLastAffected
	affectedStatusRecommended

	maxaffectedStatusType
)

var genaffectedStatusTypeToXMLStr = map[expaffectedStatusType]string{
	expaffectedStatusType(affectedStatusFirstAffected):    "First Affected",
	expaffectedStatusType(affectedStatusFirstFixed):       "First Fixed",
	expaffectedStatusType(affectedStatusFixed):            "Fixed",
	expaffectedStatusType(affectedStatusKnownAffected):    "Known Affected",
	expaffectedStatusType(affectedStatusKnownNotAffected): "Known Not Affected",
	expaffectedStatusType(affectedStatusLastAffected):     "Last Affected",
	expaffectedStatusType(affectedStatusRecommended):      "Recommended",
}

var genXMLStrToaffectedStatusType = map[string]expaffectedStatusType{
	"First Affected":     expaffectedStatusType(affectedStatusFirstAffected),
	"First Fixed":        expaffectedStatusType(affectedStatusFirstFixed),
	"Fixed":              expaffectedStatusType(affectedStatusFixed),
	"Known Affected":     expaffectedStatusType(affectedStatusKnownAffected),
	"Known Not Affected": expaffectedStatusType(affectedStatusKnownNotAffected),
	"Last Affected":      expaffectedStatusType(affectedStatusLastAffected),
	"Recommended":        expaffectedStatusType(affectedStatusRecommended),
}

// UnmarshalXML implemented to support reading from XML.
func (obj *expaffectedStatusType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	s, err := xmlElemAsString(d, start)
	if err != nil {
		return fmt.Errorf("problem decoding affectedStatusType: %v", err)
	}
	var ok bool
	if *obj, ok = genXMLStrToaffectedStatusType[s]; !ok {
		return fmt.Errorf("unrecognized affectedStatusType value %v", s)
	}
	return nil
}

func (obj *expaffectedStatusType) mapXMLValue(s string) error {
	var ok bool
	if *obj, ok = genXMLStrToaffectedStatusType[s]; !ok {
		return fmt.Errorf("unrecognized affectedStatusType value %v", s)
	}
	return nil
}

// UnmarshalXMLAttr implemented to support reading from XML
func (obj *expaffectedStatusType) UnmarshalXMLAttr(attr xml.Attr) error {
	return obj.mapXMLValue(attr.Value)
}

// MarshalXMLAttr implemented to support writing to XML.
func (obj expaffectedStatusType) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	s, ok := genaffectedStatusTypeToXMLStr[obj]
	if !ok {
		return xml.Attr{}, fmt.Errorf("unrecognized affectedStatusType value %v", obj)
	}
	return xml.Attr{Name: name, Value: s}, nil
}

// MarshalXML implemented to support writing to XML.
func (obj expaffectedStatusType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	s, ok := genaffectedStatusTypeToXMLStr[obj]
	if !ok {
		return fmt.Errorf("unrecognized affectedStatusType %v", obj)
	}
	return e.EncodeElement(s, start)
}

var genJSONStrToaffectedStatusType = map[string]expaffectedStatusType{
	"first_affected":     expaffectedStatusType(affectedStatusFirstAffected),
	"first_fixed":        expaffectedStatusType(affectedStatusFirstFixed),
	"fixed":              expaffectedStatusType(affectedStatusFixed),
	"known_affected":     expaffectedStatusType(affectedStatusKnownAffected),
	"known_not_affected": expaffectedStatusType(affectedStatusKnownNotAffected),
	"last_affected":      expaffectedStatusType(affectedStatusLastAffected),
	"recommended":        expaffectedStatusType(affectedStatusRecommended),
}

var genaffectedStatusTypeToJSONStr = map[expaffectedStatusType]string{
	expaffectedStatusType(affectedStatusFirstAffected):    "first_affected",
	expaffectedStatusType(affectedStatusFirstFixed):       "first_fixed",
	expaffectedStatusType(affectedStatusFixed):            "fixed",
	expaffectedStatusType(affectedStatusKnownAffected):    "known_affected",
	expaffectedStatusType(affectedStatusKnownNotAffected): "known_not_affected",
	expaffectedStatusType(affectedStatusLastAffected):     "last_affected",
	expaffectedStatusType(affectedStatusRecommended):      "recommended",
}

// UnmarshalJSON implemented to support writing to XML.
func (obj *expaffectedStatusType) UnmarshalJSON(data []byte) error {
	var ok bool
	if *obj, ok = genJSONStrToaffectedStatusType[noQuotes(data)]; !ok {
		return fmt.Errorf("unrecognized affectedStatusType value %v", string(data))
	}
	return nil
}

// MarshalJSON implemented to support writing to XML.
func (obj expaffectedStatusType) MarshalJSON() ([]byte, error) {
	s, ok := genaffectedStatusTypeToJSONStr[obj]
	if !ok {
		return nil, fmt.Errorf("unrecognized affectedStatusType value %v", obj)
	}
	return json.Marshal(s)
}

func (obj affectedStatusType) check(val *validator) {
	if obj < 0 || obj >= maxaffectedStatusType {
		val.err(fmt.Sprintf("unrecognized affectedStatusType %v", obj))
	}
}

/*******************************************************************************
* Generated type RemedyType
*******************************************************************************/

// RemedyType enumerates the types of remedies for a vulnerability.
type RemedyType int
type expRemedyType RemedyType

// Values for RemedyType
const (
	RemedyWorkaround RemedyType = iota
	RemedyMitigation
	RemedyVendorFix
	RemedyNoneAvailable
	RemedyWillNotFix

	maxRemedyType
)

var genRemedyTypeToXMLStr = map[expRemedyType]string{
	expRemedyType(RemedyWorkaround):    "Workaround",
	expRemedyType(RemedyMitigation):    "Mitigation",
	expRemedyType(RemedyVendorFix):     "Vendor Fix",
	expRemedyType(RemedyNoneAvailable): "None Available",
	expRemedyType(RemedyWillNotFix):    "Will Not Fix",
}

var genXMLStrToRemedyType = map[string]expRemedyType{
	"Workaround":     expRemedyType(RemedyWorkaround),
	"Mitigation":     expRemedyType(RemedyMitigation),
	"Vendor Fix":     expRemedyType(RemedyVendorFix),
	"None Available": expRemedyType(RemedyNoneAvailable),
	"Will Not Fix":   expRemedyType(RemedyWillNotFix),
}

// UnmarshalXML implemented to support reading from XML.
func (obj *expRemedyType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	s, err := xmlElemAsString(d, start)
	if err != nil {
		return fmt.Errorf("problem decoding RemedyType: %v", err)
	}
	var ok bool
	if *obj, ok = genXMLStrToRemedyType[s]; !ok {
		return fmt.Errorf("unrecognized RemedyType value %v", s)
	}
	return nil
}

func (obj *expRemedyType) mapXMLValue(s string) error {
	var ok bool
	if *obj, ok = genXMLStrToRemedyType[s]; !ok {
		return fmt.Errorf("unrecognized RemedyType value %v", s)
	}
	return nil
}

// UnmarshalXMLAttr implemented to support reading from XML
func (obj *expRemedyType) UnmarshalXMLAttr(attr xml.Attr) error {
	return obj.mapXMLValue(attr.Value)
}

// MarshalXMLAttr implemented to support writing to XML.
func (obj expRemedyType) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	s, ok := genRemedyTypeToXMLStr[obj]
	if !ok {
		return xml.Attr{}, fmt.Errorf("unrecognized RemedyType value %v", obj)
	}
	return xml.Attr{Name: name, Value: s}, nil
}

// MarshalXML implemented to support writing to XML.
func (obj expRemedyType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	s, ok := genRemedyTypeToXMLStr[obj]
	if !ok {
		return fmt.Errorf("unrecognized RemedyType %v", obj)
	}
	return e.EncodeElement(s, start)
}

var genJSONStrToRemedyType = map[string]expRemedyType{
	"workaround":     expRemedyType(RemedyWorkaround),
	"mitigation":     expRemedyType(RemedyMitigation),
	"vendor_fix":     expRemedyType(RemedyVendorFix),
	"none_available": expRemedyType(RemedyNoneAvailable),
	"will_not_fix":   expRemedyType(RemedyWillNotFix),
}

var genRemedyTypeToJSONStr = map[expRemedyType]string{
	expRemedyType(RemedyWorkaround):    "workaround",
	expRemedyType(RemedyMitigation):    "mitigation",
	expRemedyType(RemedyVendorFix):     "vendor_fix",
	expRemedyType(RemedyNoneAvailable): "none_available",
	expRemedyType(RemedyWillNotFix):    "will_not_fix",
}

// UnmarshalJSON implemented to support writing to XML.
func (obj *expRemedyType) UnmarshalJSON(data []byte) error {
	var ok bool
	if *obj, ok = genJSONStrToRemedyType[noQuotes(data)]; !ok {
		return fmt.Errorf("unrecognized RemedyType value %v", string(data))
	}
	return nil
}

// MarshalJSON implemented to support writing to XML.
func (obj expRemedyType) MarshalJSON() ([]byte, error) {
	s, ok := genRemedyTypeToJSONStr[obj]
	if !ok {
		return nil, fmt.Errorf("unrecognized RemedyType value %v", obj)
	}
	return json.Marshal(s)
}

func (obj RemedyType) check(val *validator) {
	if obj < 0 || obj >= maxRemedyType {
		val.err(fmt.Sprintf("unrecognized RemedyType %v", obj))
	}
}

/*******************************************************************************
* Generated type DocStatus
*******************************************************************************/

// DocStatus enumerates the possible states of a document.
type DocStatus int
type expDocStatus DocStatus

// Values for DocStatus
const (
	DocStatusDraft DocStatus = iota
	DocStatusInterim
	DocStatusFinal

	maxDocStatus
)

var genDocStatusToXMLStr = map[expDocStatus]string{
	expDocStatus(DocStatusDraft):   "Draft",
	expDocStatus(DocStatusInterim): "Interim",
	expDocStatus(DocStatusFinal):   "Final",
}

var genXMLStrToDocStatus = map[string]expDocStatus{
	"Draft":   expDocStatus(DocStatusDraft),
	"Interim": expDocStatus(DocStatusInterim),
	"Final":   expDocStatus(DocStatusFinal),
}

// UnmarshalXML implemented to support reading from XML.
func (obj *expDocStatus) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	s, err := xmlElemAsString(d, start)
	if err != nil {
		return fmt.Errorf("problem decoding DocStatus: %v", err)
	}
	var ok bool
	if *obj, ok = genXMLStrToDocStatus[s]; !ok {
		return fmt.Errorf("unrecognized DocStatus value %v", s)
	}
	return nil
}

func (obj *expDocStatus) mapXMLValue(s string) error {
	var ok bool
	if *obj, ok = genXMLStrToDocStatus[s]; !ok {
		return fmt.Errorf("unrecognized DocStatus value %v", s)
	}
	return nil
}

// UnmarshalXMLAttr implemented to support reading from XML
func (obj *expDocStatus) UnmarshalXMLAttr(attr xml.Attr) error {
	return obj.mapXMLValue(attr.Value)
}

// MarshalXMLAttr implemented to support writing to XML.
func (obj expDocStatus) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	s, ok := genDocStatusToXMLStr[obj]
	if !ok {
		return xml.Attr{}, fmt.Errorf("unrecognized DocStatus value %v", obj)
	}
	return xml.Attr{Name: name, Value: s}, nil
}

// MarshalXML implemented to support writing to XML.
func (obj expDocStatus) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	s, ok := genDocStatusToXMLStr[obj]
	if !ok {
		return fmt.Errorf("unrecognized DocStatus %v", obj)
	}
	return e.EncodeElement(s, start)
}

var genJSONStrToDocStatus = map[string]expDocStatus{
	"draft":   expDocStatus(DocStatusDraft),
	"interim": expDocStatus(DocStatusInterim),
	"final":   expDocStatus(DocStatusFinal),
}

var genDocStatusToJSONStr = map[expDocStatus]string{
	expDocStatus(DocStatusDraft):   "draft",
	expDocStatus(DocStatusInterim): "interim",
	expDocStatus(DocStatusFinal):   "final",
}

// UnmarshalJSON implemented to support writing to XML.
func (obj *expDocStatus) UnmarshalJSON(data []byte) error {
	var ok bool
	if *obj, ok = genJSONStrToDocStatus[noQuotes(data)]; !ok {
		return fmt.Errorf("unrecognized DocStatus value %v", string(data))
	}
	return nil
}

// MarshalJSON implemented to support writing to XML.
func (obj expDocStatus) MarshalJSON() ([]byte, error) {
	s, ok := genDocStatusToJSONStr[obj]
	if !ok {
		return nil, fmt.Errorf("unrecognized DocStatus value %v", obj)
	}
	return json.Marshal(s)
}

func (obj DocStatus) check(val *validator) {
	if obj < 0 || obj >= maxDocStatus {
		val.err(fmt.Sprintf("unrecognized DocStatus %v", obj))
	}
}

/*******************************************************************************
* Generated type ReferenceType
*******************************************************************************/

// ReferenceType enumerates whether a reference is self or external.
type ReferenceType int
type expReferenceType ReferenceType

// Values for ReferenceType
const (
	ReferenceExternal ReferenceType = iota
	ReferenceSelf

	maxReferenceType
)

var genReferenceTypeToXMLStr = map[expReferenceType]string{
	expReferenceType(ReferenceExternal): "External",
	expReferenceType(ReferenceSelf):     "Self",
}

var genXMLStrToReferenceType = map[string]expReferenceType{
	"External": expReferenceType(ReferenceExternal),
	"Self":     expReferenceType(ReferenceSelf),
}

// UnmarshalXML implemented to support reading from XML.
func (obj *expReferenceType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	s, err := xmlElemAsString(d, start)
	if err != nil {
		return fmt.Errorf("problem decoding ReferenceType: %v", err)
	}
	var ok bool
	if *obj, ok = genXMLStrToReferenceType[s]; !ok {
		return fmt.Errorf("unrecognized ReferenceType value %v", s)
	}
	return nil
}

func (obj *expReferenceType) mapXMLValue(s string) error {
	var ok bool
	if *obj, ok = genXMLStrToReferenceType[s]; !ok {
		return fmt.Errorf("unrecognized ReferenceType value %v", s)
	}
	return nil
}

// UnmarshalXMLAttr implemented to support reading from XML
func (obj *expReferenceType) UnmarshalXMLAttr(attr xml.Attr) error {
	return obj.mapXMLValue(attr.Value)
}

// MarshalXMLAttr implemented to support writing to XML.
func (obj expReferenceType) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	s, ok := genReferenceTypeToXMLStr[obj]
	if !ok {
		return xml.Attr{}, fmt.Errorf("unrecognized ReferenceType value %v", obj)
	}
	return xml.Attr{Name: name, Value: s}, nil
}

// MarshalXML implemented to support writing to XML.
func (obj expReferenceType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	s, ok := genReferenceTypeToXMLStr[obj]
	if !ok {
		return fmt.Errorf("unrecognized ReferenceType %v", obj)
	}
	return e.EncodeElement(s, start)
}

var genJSONStrToReferenceType = map[string]expReferenceType{
	"external": expReferenceType(ReferenceExternal),
	"self":     expReferenceType(ReferenceSelf),
}

var genReferenceTypeToJSONStr = map[expReferenceType]string{
	expReferenceType(ReferenceExternal): "external",
	expReferenceType(ReferenceSelf):     "self",
}

// UnmarshalJSON implemented to support writing to XML.
func (obj *expReferenceType) UnmarshalJSON(data []byte) error {
	var ok bool
	if *obj, ok = genJSONStrToReferenceType[noQuotes(data)]; !ok {
		return fmt.Errorf("unrecognized ReferenceType value %v", string(data))
	}
	return nil
}

// MarshalJSON implemented to support writing to XML.
func (obj expReferenceType) MarshalJSON() ([]byte, error) {
	s, ok := genReferenceTypeToJSONStr[obj]
	if !ok {
		return nil, fmt.Errorf("unrecognized ReferenceType value %v", obj)
	}
	return json.Marshal(s)
}

func (obj ReferenceType) check(val *validator) {
	if obj < 0 || obj >= maxReferenceType {
		val.err(fmt.Sprintf("unrecognized ReferenceType %v", obj))
	}
}

/*******************************************************************************
* Generated type NoteType
*******************************************************************************/

// NoteType enumerates the different types of Notes.
type NoteType int
type expNoteType NoteType

// Values for NoteType
const (
	NoteDescription NoteType = iota
	NoteDetails
	NoteFAQ
	NoteGeneral
	NoteLegalDisclaimer
	NoteOther
	NoteSummary

	maxNoteType
)

var genNoteTypeToXMLStr = map[expNoteType]string{
	expNoteType(NoteDescription):     "Description",
	expNoteType(NoteDetails):         "Details",
	expNoteType(NoteFAQ):             "FAQ",
	expNoteType(NoteGeneral):         "General",
	expNoteType(NoteLegalDisclaimer): "Legal Disclaimer",
	expNoteType(NoteOther):           "Other",
	expNoteType(NoteSummary):         "Summary",
}

var genXMLStrToNoteType = map[string]expNoteType{
	"Description":      expNoteType(NoteDescription),
	"Details":          expNoteType(NoteDetails),
	"FAQ":              expNoteType(NoteFAQ),
	"General":          expNoteType(NoteGeneral),
	"Legal Disclaimer": expNoteType(NoteLegalDisclaimer),
	"Other":            expNoteType(NoteOther),
	"Summary":          expNoteType(NoteSummary),
}

// UnmarshalXML implemented to support reading from XML.
func (obj *expNoteType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	s, err := xmlElemAsString(d, start)
	if err != nil {
		return fmt.Errorf("problem decoding NoteType: %v", err)
	}
	var ok bool
	if *obj, ok = genXMLStrToNoteType[s]; !ok {
		return fmt.Errorf("unrecognized NoteType value %v", s)
	}
	return nil
}

func (obj *expNoteType) mapXMLValue(s string) error {
	var ok bool
	if *obj, ok = genXMLStrToNoteType[s]; !ok {
		return fmt.Errorf("unrecognized NoteType value %v", s)
	}
	return nil
}

// UnmarshalXMLAttr implemented to support reading from XML
func (obj *expNoteType) UnmarshalXMLAttr(attr xml.Attr) error {
	return obj.mapXMLValue(attr.Value)
}

// MarshalXMLAttr implemented to support writing to XML.
func (obj expNoteType) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	s, ok := genNoteTypeToXMLStr[obj]
	if !ok {
		return xml.Attr{}, fmt.Errorf("unrecognized NoteType value %v", obj)
	}
	return xml.Attr{Name: name, Value: s}, nil
}

// MarshalXML implemented to support writing to XML.
func (obj expNoteType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	s, ok := genNoteTypeToXMLStr[obj]
	if !ok {
		return fmt.Errorf("unrecognized NoteType %v", obj)
	}
	return e.EncodeElement(s, start)
}

var genJSONStrToNoteType = map[string]expNoteType{
	"description":      expNoteType(NoteDescription),
	"details":          expNoteType(NoteDetails),
	"faq":              expNoteType(NoteFAQ),
	"general":          expNoteType(NoteGeneral),
	"legal_disclaimer": expNoteType(NoteLegalDisclaimer),
	"other":            expNoteType(NoteOther),
	"summary":          expNoteType(NoteSummary),
}

var genNoteTypeToJSONStr = map[expNoteType]string{
	expNoteType(NoteDescription):     "description",
	expNoteType(NoteDetails):         "details",
	expNoteType(NoteFAQ):             "faq",
	expNoteType(NoteGeneral):         "general",
	expNoteType(NoteLegalDisclaimer): "legal_disclaimer",
	expNoteType(NoteOther):           "other",
	expNoteType(NoteSummary):         "summary",
}

// UnmarshalJSON implemented to support writing to XML.
func (obj *expNoteType) UnmarshalJSON(data []byte) error {
	var ok bool
	if *obj, ok = genJSONStrToNoteType[noQuotes(data)]; !ok {
		return fmt.Errorf("unrecognized NoteType value %v", string(data))
	}
	return nil
}

// MarshalJSON implemented to support writing to XML.
func (obj expNoteType) MarshalJSON() ([]byte, error) {
	s, ok := genNoteTypeToJSONStr[obj]
	if !ok {
		return nil, fmt.Errorf("unrecognized NoteType value %v", obj)
	}
	return json.Marshal(s)
}

func (obj NoteType) check(val *validator) {
	if obj < 0 || obj >= maxNoteType {
		val.err(fmt.Sprintf("unrecognized NoteType %v", obj))
	}
}

/*******************************************************************************
* Generated type PublisherType
*******************************************************************************/

// PublisherType enumerates the different publishers of vulnerabilities.
type PublisherType int
type expPublisherType PublisherType

// Values for PublisherType
const (
	PubTypeVendor PublisherType = iota
	PubTypeDiscoverer
	PubTypeCoordinator
	PubTypeUser
	PubTypeOther

	maxPublisherType
)

var genPublisherTypeToXMLStr = map[expPublisherType]string{
	expPublisherType(PubTypeVendor):      "Vendor",
	expPublisherType(PubTypeDiscoverer):  "Discoverer",
	expPublisherType(PubTypeCoordinator): "Coordinator",
	expPublisherType(PubTypeUser):        "User",
	expPublisherType(PubTypeOther):       "Other",
}

var genXMLStrToPublisherType = map[string]expPublisherType{
	"Vendor":      expPublisherType(PubTypeVendor),
	"Discoverer":  expPublisherType(PubTypeDiscoverer),
	"Coordinator": expPublisherType(PubTypeCoordinator),
	"User":        expPublisherType(PubTypeUser),
	"Other":       expPublisherType(PubTypeOther),
}

// UnmarshalXML implemented to support reading from XML.
func (obj *expPublisherType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	s, err := xmlElemAsString(d, start)
	if err != nil {
		return fmt.Errorf("problem decoding PublisherType: %v", err)
	}
	var ok bool
	if *obj, ok = genXMLStrToPublisherType[s]; !ok {
		return fmt.Errorf("unrecognized PublisherType value %v", s)
	}
	return nil
}

func (obj *expPublisherType) mapXMLValue(s string) error {
	var ok bool
	if *obj, ok = genXMLStrToPublisherType[s]; !ok {
		return fmt.Errorf("unrecognized PublisherType value %v", s)
	}
	return nil
}

// UnmarshalXMLAttr implemented to support reading from XML
func (obj *expPublisherType) UnmarshalXMLAttr(attr xml.Attr) error {
	return obj.mapXMLValue(attr.Value)
}

// MarshalXMLAttr implemented to support writing to XML.
func (obj expPublisherType) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	s, ok := genPublisherTypeToXMLStr[obj]
	if !ok {
		return xml.Attr{}, fmt.Errorf("unrecognized PublisherType value %v", obj)
	}
	return xml.Attr{Name: name, Value: s}, nil
}

// MarshalXML implemented to support writing to XML.
func (obj expPublisherType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	s, ok := genPublisherTypeToXMLStr[obj]
	if !ok {
		return fmt.Errorf("unrecognized PublisherType %v", obj)
	}
	return e.EncodeElement(s, start)
}

var genJSONStrToPublisherType = map[string]expPublisherType{
	"vendor":      expPublisherType(PubTypeVendor),
	"discoverer":  expPublisherType(PubTypeDiscoverer),
	"coordinator": expPublisherType(PubTypeCoordinator),
	"user":        expPublisherType(PubTypeUser),
	"other":       expPublisherType(PubTypeOther),
}

var genPublisherTypeToJSONStr = map[expPublisherType]string{
	expPublisherType(PubTypeVendor):      "vendor",
	expPublisherType(PubTypeDiscoverer):  "discoverer",
	expPublisherType(PubTypeCoordinator): "coordinator",
	expPublisherType(PubTypeUser):        "user",
	expPublisherType(PubTypeOther):       "other",
}

// UnmarshalJSON implemented to support writing to XML.
func (obj *expPublisherType) UnmarshalJSON(data []byte) error {
	var ok bool
	if *obj, ok = genJSONStrToPublisherType[noQuotes(data)]; !ok {
		return fmt.Errorf("unrecognized PublisherType value %v", string(data))
	}
	return nil
}

// MarshalJSON implemented to support writing to XML.
func (obj expPublisherType) MarshalJSON() ([]byte, error) {
	s, ok := genPublisherTypeToJSONStr[obj]
	if !ok {
		return nil, fmt.Errorf("unrecognized PublisherType value %v", obj)
	}
	return json.Marshal(s)
}

func (obj PublisherType) check(val *validator) {
	if obj < 0 || obj >= maxPublisherType {
		val.err(fmt.Sprintf("unrecognized PublisherType %v", obj))
	}
}

/*******************************************************************************
* Generated type BranchType
*******************************************************************************/

// BranchType captures the type of branch in the product tree.
type BranchType int
type expBranchType BranchType

// Values for BranchType
const (
	BranchVendor BranchType = iota
	BranchProductFamily
	BranchProductName
	BranchProductVersion
	BranchPatchLevel
	BranchServicePack
	BranchArchitecture
	BranchLanguage
	BranchLegacy
	BranchSpecification
	BranchHostName
	BranchRealm
	BranchResource

	maxBranchType
)

var genBranchTypeToXMLStr = map[expBranchType]string{
	expBranchType(BranchVendor):         "Vendor",
	expBranchType(BranchProductFamily):  "Product Family",
	expBranchType(BranchProductName):    "Product Name",
	expBranchType(BranchProductVersion): "Product Version",
	expBranchType(BranchPatchLevel):     "Patch Level",
	expBranchType(BranchServicePack):    "Service Pack",
	expBranchType(BranchArchitecture):   "Architecture",
	expBranchType(BranchLanguage):       "Language",
	expBranchType(BranchLegacy):         "Legacy",
	expBranchType(BranchSpecification):  "Specification",
	expBranchType(BranchHostName):       "Host Name",
	expBranchType(BranchRealm):          "Realm",
	expBranchType(BranchResource):       "Resource",
}

var genXMLStrToBranchType = map[string]expBranchType{
	"Vendor":          expBranchType(BranchVendor),
	"Product Family":  expBranchType(BranchProductFamily),
	"Product Name":    expBranchType(BranchProductName),
	"Product Version": expBranchType(BranchProductVersion),
	"Patch Level":     expBranchType(BranchPatchLevel),
	"Service Pack":    expBranchType(BranchServicePack),
	"Architecture":    expBranchType(BranchArchitecture),
	"Language":        expBranchType(BranchLanguage),
	"Legacy":          expBranchType(BranchLegacy),
	"Specification":   expBranchType(BranchSpecification),
	"Host Name":       expBranchType(BranchHostName),
	"Realm":           expBranchType(BranchRealm),
	"Resource":        expBranchType(BranchResource),
}

// UnmarshalXML implemented to support reading from XML.
func (obj *expBranchType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	s, err := xmlElemAsString(d, start)
	if err != nil {
		return fmt.Errorf("problem decoding BranchType: %v", err)
	}
	var ok bool
	if *obj, ok = genXMLStrToBranchType[s]; !ok {
		return fmt.Errorf("unrecognized BranchType value %v", s)
	}
	return nil
}

func (obj *expBranchType) mapXMLValue(s string) error {
	var ok bool
	if *obj, ok = genXMLStrToBranchType[s]; !ok {
		return fmt.Errorf("unrecognized BranchType value %v", s)
	}
	return nil
}

// UnmarshalXMLAttr implemented to support reading from XML
func (obj *expBranchType) UnmarshalXMLAttr(attr xml.Attr) error {
	return obj.mapXMLValue(attr.Value)
}

// MarshalXMLAttr implemented to support writing to XML.
func (obj expBranchType) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	s, ok := genBranchTypeToXMLStr[obj]
	if !ok {
		return xml.Attr{}, fmt.Errorf("unrecognized BranchType value %v", obj)
	}
	return xml.Attr{Name: name, Value: s}, nil
}

// MarshalXML implemented to support writing to XML.
func (obj expBranchType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	s, ok := genBranchTypeToXMLStr[obj]
	if !ok {
		return fmt.Errorf("unrecognized BranchType %v", obj)
	}
	return e.EncodeElement(s, start)
}

var genJSONStrToBranchType = map[string]expBranchType{
	"vendor":          expBranchType(BranchVendor),
	"product_family":  expBranchType(BranchProductFamily),
	"product_name":    expBranchType(BranchProductName),
	"product_version": expBranchType(BranchProductVersion),
	"patch_level":     expBranchType(BranchPatchLevel),
	"service_pack":    expBranchType(BranchServicePack),
	"architecture":    expBranchType(BranchArchitecture),
	"language":        expBranchType(BranchLanguage),
	"legacy":          expBranchType(BranchLegacy),
	"specification":   expBranchType(BranchSpecification),
	"host_name":       expBranchType(BranchHostName),
	"realm":           expBranchType(BranchRealm),
	"resource":        expBranchType(BranchResource),
}

var genBranchTypeToJSONStr = map[expBranchType]string{
	expBranchType(BranchVendor):         "vendor",
	expBranchType(BranchProductFamily):  "product_family",
	expBranchType(BranchProductName):    "product_name",
	expBranchType(BranchProductVersion): "product_version",
	expBranchType(BranchPatchLevel):     "patch_level",
	expBranchType(BranchServicePack):    "service_pack",
	expBranchType(BranchArchitecture):   "architecture",
	expBranchType(BranchLanguage):       "language",
	expBranchType(BranchLegacy):         "legacy",
	expBranchType(BranchSpecification):  "specification",
	expBranchType(BranchHostName):       "host_name",
	expBranchType(BranchRealm):          "realm",
	expBranchType(BranchResource):       "resource",
}

// UnmarshalJSON implemented to support writing to XML.
func (obj *expBranchType) UnmarshalJSON(data []byte) error {
	var ok bool
	if *obj, ok = genJSONStrToBranchType[noQuotes(data)]; !ok {
		return fmt.Errorf("unrecognized BranchType value %v", string(data))
	}
	return nil
}

// MarshalJSON implemented to support writing to XML.
func (obj expBranchType) MarshalJSON() ([]byte, error) {
	s, ok := genBranchTypeToJSONStr[obj]
	if !ok {
		return nil, fmt.Errorf("unrecognized BranchType value %v", obj)
	}
	return json.Marshal(s)
}

func (obj BranchType) check(val *validator) {
	if obj < 0 || obj >= maxBranchType {
		val.err(fmt.Sprintf("unrecognized BranchType %v", obj))
	}
}

/*******************************************************************************
* Generated type ThreatType
*******************************************************************************/

// ThreatType captures the type of threat.
type ThreatType int
type expThreatType ThreatType

// Values for ThreatType
const (
	ThreatImpact ThreatType = iota
	ThreatExploitStatus
	ThreatTargetSet

	maxThreatType
)

var genThreatTypeToXMLStr = map[expThreatType]string{
	expThreatType(ThreatImpact):        "Impact",
	expThreatType(ThreatExploitStatus): "Exploit Status",
	expThreatType(ThreatTargetSet):     "Target Set",
}

var genXMLStrToThreatType = map[string]expThreatType{
	"Impact":         expThreatType(ThreatImpact),
	"Exploit Status": expThreatType(ThreatExploitStatus),
	"Target Set":     expThreatType(ThreatTargetSet),
}

// UnmarshalXML implemented to support reading from XML.
func (obj *expThreatType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	s, err := xmlElemAsString(d, start)
	if err != nil {
		return fmt.Errorf("problem decoding ThreatType: %v", err)
	}
	var ok bool
	if *obj, ok = genXMLStrToThreatType[s]; !ok {
		return fmt.Errorf("unrecognized ThreatType value %v", s)
	}
	return nil
}

func (obj *expThreatType) mapXMLValue(s string) error {
	var ok bool
	if *obj, ok = genXMLStrToThreatType[s]; !ok {
		return fmt.Errorf("unrecognized ThreatType value %v", s)
	}
	return nil
}

// UnmarshalXMLAttr implemented to support reading from XML
func (obj *expThreatType) UnmarshalXMLAttr(attr xml.Attr) error {
	return obj.mapXMLValue(attr.Value)
}

// MarshalXMLAttr implemented to support writing to XML.
func (obj expThreatType) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	s, ok := genThreatTypeToXMLStr[obj]
	if !ok {
		return xml.Attr{}, fmt.Errorf("unrecognized ThreatType value %v", obj)
	}
	return xml.Attr{Name: name, Value: s}, nil
}

// MarshalXML implemented to support writing to XML.
func (obj expThreatType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	s, ok := genThreatTypeToXMLStr[obj]
	if !ok {
		return fmt.Errorf("unrecognized ThreatType %v", obj)
	}
	return e.EncodeElement(s, start)
}

var genJSONStrToThreatType = map[string]expThreatType{
	"impact":         expThreatType(ThreatImpact),
	"exploit_status": expThreatType(ThreatExploitStatus),
	"target_set":     expThreatType(ThreatTargetSet),
}

var genThreatTypeToJSONStr = map[expThreatType]string{
	expThreatType(ThreatImpact):        "impact",
	expThreatType(ThreatExploitStatus): "exploit_status",
	expThreatType(ThreatTargetSet):     "target_set",
}

// UnmarshalJSON implemented to support writing to XML.
func (obj *expThreatType) UnmarshalJSON(data []byte) error {
	var ok bool
	if *obj, ok = genJSONStrToThreatType[noQuotes(data)]; !ok {
		return fmt.Errorf("unrecognized ThreatType value %v", string(data))
	}
	return nil
}

// MarshalJSON implemented to support writing to XML.
func (obj expThreatType) MarshalJSON() ([]byte, error) {
	s, ok := genThreatTypeToJSONStr[obj]
	if !ok {
		return nil, fmt.Errorf("unrecognized ThreatType value %v", obj)
	}
	return json.Marshal(s)
}

func (obj ThreatType) check(val *validator) {
	if obj < 0 || obj >= maxThreatType {
		val.err(fmt.Sprintf("unrecognized ThreatType %v", obj))
	}
}
